
////////
class BaseTask
{
public:
    virtual ~BaseTask() {};
    virtual void excute() = 0;
};

////////
#include <chrono>
#include <iostream>
#include <thread>
#include <ctime>
#include <cstdlib>

#include "BaseTask.h"

class TestTask : public BaseTask
{
public:
    virtual void excute()
    {
        srand((unsigned int)time(NULL));
        std::this_thread::sleep_for(std::chrono::milliseconds(rand() % 1000));
        std::cout << std::this_thread::get_id() << ": Haha\n";
        std::this_thread::sleep_for(std::chrono::seconds(2));
    }

private:

};

////////
#include <thread>
#include <list>
#include <memory>
#include <mutex>
#include <condition_variable>

#include "BaseTask.h"

class TaskList
{
public:
    ~TaskList();

    void addTask(BaseTask* task);
    BaseTask* getTask();
    void popTask();
    bool empty();
    int size();

private:
    //std::list<BaseTask*> mTaskList;
    std::list<std::unique_ptr<BaseTask>> mTaskList;
};

class ThreadPool
{
public:
    ThreadPool() : mTaskLimit(0), mThreadLimit(0), mInitThdnum(0), mContinue(true) {}
    ~ThreadPool();
    
    // initThreadNum -- number of working threads
    // maxTaskNum -- max task number in task list
    // maxThreadNum -- max working thread number
    void init(int initThreadNum, int maxTaskNum, int maxThreadNum);
    void addTask(BaseTask* task);
    void shutdown();

private:
    void work();
    void wait();

private:
    int mTaskLimit;
    int mThreadLimit;
    int mInitThdnum;
    bool mContinue;

    TaskList mTasks;
    std::list<std::thread> mThreadList;
    std::mutex mMutex;
    std::condition_variable mWakeCond;
    std::condition_variable mPushCond;
};

////////


#include "ThreadPool.h"

#include <iostream>

ThreadPool::~ThreadPool()
{
    this->wait();
}

void ThreadPool::init(int initThreadNum, int maxTaskNum, int maxThreadNum)
{
    mInitThdnum = initThreadNum;
    mThreadLimit = maxThreadNum;
    mTaskLimit = maxTaskNum;

    // 初始化工作线程
    for (int i = 0; i < initThreadNum; ++i)
    {
        mThreadList.push_back(std::thread([&]() {
            this->work();            
            })
        );
    }
}

void ThreadPool::wait()
{
    for (auto& thd : mThreadList)
    {
        thd.join();
    }
    mThreadList.clear();
}

void ThreadPool::addTask(BaseTask* task)
{
    if (!task)
    {
        return;
    }

    // 看任务队列是否已达阈值以及线程是否已达上限
    std::unique_lock<std::mutex> ulock(mMutex);
    if (mTasks.size() < mTaskLimit)
    {
        mTasks.addTask(task);
        mWakeCond.notify_one();
    }
    else if (mThreadList.size() < mThreadLimit)
    {
        mThreadList.push_back(std::thread([&]() {
            std::cout << "Before new thread\n";
            this->work();
        }));
        mTasks.addTask(task);
        mWakeCond.notify_one();
    }
    else
    {
        mPushCond.wait(ulock, [&]() {
            return (mTasks.size() < mTaskLimit) || (mThreadList.size() < mThreadLimit);
        });
    }
}

void ThreadPool::shutdown()
{
    mContinue = false;
}

void ThreadPool::work()
{
    while (true)
    {
        std::unique_ptr<BaseTask> task;

        {
            std::unique_lock<std::mutex> ulock(mMutex);
            mWakeCond.wait(ulock, [&]() {
                return !this->mContinue || !this->mTasks.empty();
                });
            if (!this->mContinue)
            {
                return;
            }

            task = std::unique_ptr<BaseTask>(mTasks.getTask());
            mTasks.popTask();

        }

        // 当任务队列减少时，唤醒任务队列
        if (mTasks.size() < mTaskLimit)
        {
            mPushCond.notify_one();
        }
        task->excute();

        // 根据实时的任务情况，适当减少当前运行的线程
        ///TODO...
        if (mTasks.size() < mTaskLimit / 2 && mThreadList.size() > mInitThdnum)
        {
            std::cout << std::this_thread::get_id() << " quit\n";
            return;
        }
    }
}




TaskList::~TaskList()
{
}

void TaskList::addTask(BaseTask* task)
{
    mTaskList.push_back(std::unique_ptr<BaseTask>(task));
}

BaseTask* TaskList::getTask()
{
    if (!mTaskList.empty())
    {
        return mTaskList.front().release();
    }
    else
    {
        return nullptr;
    }
}

void TaskList::popTask()
{
    if (!mTaskList.empty())
    {
        mTaskList.pop_front();
    }
}

bool TaskList::empty()
{
    return mTaskList.empty();
}

int TaskList::size()
{
    return mTaskList.size();
}

////////

